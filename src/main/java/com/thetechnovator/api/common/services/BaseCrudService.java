package com.thetechnovator.api.common.services;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import jakarta.persistence.Id;
import jakarta.persistence.Temporal;
import jakarta.persistence.TemporalType;
import jakarta.persistence.Transient;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validator;
import jakarta.validation.groups.Default;

import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.DiffBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.transaction.annotation.Transactional;

import com.thetechnovator.api.common.annotations.AuditField;
import com.thetechnovator.api.common.annotations.AutoGeneratedUUID;
import com.thetechnovator.api.common.annotations.LifecycleStatus;
import com.thetechnovator.api.common.annotations.UniqueKey;
import com.thetechnovator.api.common.annotations.AuditField.AuditFieldType;
import com.thetechnovator.api.common.auditlog.AuditLog;
import com.thetechnovator.api.common.auditlog.AuditLogService;
import com.thetechnovator.api.common.auditlog.Auditable;
import com.thetechnovator.api.common.auditlog.AuditableChild;
import com.thetechnovator.api.common.auditlog.AuditableParent;
import com.thetechnovator.api.common.auditlog.AuditableReference;
import com.thetechnovator.api.common.cache.EntityCacheReference.EntityReferenceCacheEntry;
import com.thetechnovator.api.common.constants.Actions;
import com.thetechnovator.api.common.constants.Operations;
import com.thetechnovator.api.common.constants.Actions.Crud;
import com.thetechnovator.api.common.controllers.RestResponseBuilder;
import com.thetechnovator.api.common.controllers.RestResponse.ErrorResponse;
import com.thetechnovator.api.common.controllers.RestResponse.ValidationError;
import com.thetechnovator.api.common.db.EntityManagerProvider;
import com.thetechnovator.api.common.domain.AppObect;
import com.thetechnovator.api.common.events.ResourceChangeEvent;
import com.thetechnovator.api.common.exception.BadRequestException;
import com.thetechnovator.api.common.exception.InvalidRequestException;
import com.thetechnovator.api.common.exception.ValidationException;
import com.thetechnovator.api.common.repos.BaseRepository;
import com.thetechnovator.api.common.utils.BeanUtil;
import com.thetechnovator.api.common.utils.CommonUtil;
import com.thetechnovator.api.common.utils.DateUtils;
import com.thetechnovator.api.common.utils.EntityUtils;

import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.media.Schema.AccessMode;

public abstract class BaseCrudService<T, ID extends Serializable> extends BaseEntityService<T, ID> {
	private static final Logger LOG = LoggerFactory.getLogger(BaseCrudService.class);
	protected static final String STATUS_NEW = "N";
	protected static final String COMMA = ",";
	protected static final String STATUS_DEPRECATED = "D";

	@Autowired
	private Validator validator;

	@Autowired
	private AuditLogService auditService;
	@Autowired
	private ApplicationEventPublisher publisher;

	private Field statusField = null;
	private Field idField = null;
	private String statusFieldDefault = null;
	private boolean generateKey = false;
	private boolean generateKeyOptional = false;
	private Map<String, List<Field>> uniqueKeyFields;
	private Map<AuditFieldType, Field> auditFields;

	public BaseCrudService(BaseRepository<T, ID> repo, Class<T> entityClass, Class<ID> idClass) {
		super(repo, entityClass, idClass);
		this.repo = repo;
		this.entityClass = entityClass;
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, LifecycleStatus.class);
		if (fields.size() == 1) {
			statusField = fields.get(0);
			LifecycleStatus lsAnno = statusField.getAnnotation(LifecycleStatus.class);
			statusFieldDefault = lsAnno.defaultValue();
		} else if (fields.size() > 1) {
			// programming error
			throw new IllegalStateException("Only one field per entity should be set as LifeCycleStatus field");
		}
		List<Field> idFields = FieldUtils.getFieldsListWithAnnotation(entityClass, Id.class);
		if (idFields.size() != 1) {
			throw new IllegalStateException("Id field not defined or more than one Id fields are defined");
		}
		idField = idFields.get(0);

		fields = FieldUtils.getFieldsListWithAnnotation(entityClass, AutoGeneratedUUID.class);
		if (fields.size() == 1) {
			generateKey = true;
			AutoGeneratedUUID anno = fields.get(0).getAnnotation(AutoGeneratedUUID.class);
			generateKeyOptional = anno.optional();
		}
		// get unique key fields
		uniqueKeyFields = new HashMap<>();
		initUniqueKeys(entityClass, UniqueKey.class);
		// If primary key is optional, it must also be verified for uniqueness
		if (generateKeyOptional) {
			initUniqueKeys(entityClass, Id.class);
		}
		initAuditFields();
	}

	private void initAuditFields() {
		auditFields = new HashMap<>();
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, AuditField.class);
		for (Field field : fields) {
			AuditField audField = field.getAnnotation(AuditField.class);
			auditFields.put(audField.value(), field);
		}
	}

	private void initUniqueKeys(Class<T> entityClass, Class<? extends Annotation> annotaion) {
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, annotaion);
		if (fields.size() != 0) {

			for (Field field : fields) {
				Annotation uk = field.getAnnotation(annotaion);
				String key;
				if (annotaion.equals(Id.class)) {
					key = "id";
				} else {
					key = ((UniqueKey) uk).value();
				}
				List<Field> keyFields = uniqueKeyFields.get(key);
				if (keyFields == null) {
					keyFields = new ArrayList<>();
					uniqueKeyFields.put(key, keyFields);
				}
				keyFields.add(field);
			}
		}
	}

	public List<AuditLog> getHistory(ID id) {
		T obj = getById(id, true);
		if (obj != null) {
			return auditService.find((AuditableParent) obj, id, additionalHistory(id));
		} else {
			return auditService.find(getAppObjectType(), id.toString());
		}
	}

	@Transactional(readOnly = false)
	public T add(T obj) {
		validate(obj, Operations.Add.class);
		addInternal(Arrays.asList(obj));
		return obj;
	}

	@Transactional(readOnly = false)
	public void overwrite(ID id, T obj) {
		validate(obj, Operations.Overwrite.class);
		overwriteInternal(id, obj);
	}

	@Transactional(readOnly = false)
	public List<ID> addAll(List<T> objList) {
		validate(objList, Operations.Add.class);
		List<ID> result = new ArrayList<>();

		addInternal(objList);
		for (T obj: objList) {
			result.add(getId(obj));
		}

		return result;
	}

	@Transactional(readOnly = false)
	public List<ID> addOrOverwriteAll(List<T> objList) {
		return addOrOverwriteAll(objList, Operations.Overwrite.class);
	}

	@Transactional(readOnly = false)
	public List<ID> addOrUpdateAll(List<T> objList) {
		return addOrOverwriteAll(objList, Operations.Update.class);
	}

	@SuppressWarnings("unchecked")
	private ID getId(Object obj) {
		return (ID) readField(idField, obj);
	}

	private void setId(T obj, ID value) {
		writeField(idField, obj, value);
	}

	private Object readField(Field field, Object obj) {
		try {
			return FieldUtils.readField(field, obj, true);
		} catch (IllegalAccessException e) {
			// should not happen. still do not eat the exception
			throw new IllegalStateException(e);
		}
	}

	private void writeField(Field field, Object obj, Object value) {
		try {
			FieldUtils.writeField(field, obj, value, true);
		} catch (IllegalAccessException e) {
			// should not happen. still do not eat the exception
			throw new IllegalStateException(e);
		}
	}

	private List<ID> addOrOverwriteAll(List<T> objList, Class<? extends Operations.Operation> operation) {
		List<T> addList = new ArrayList<>();
		List<T> updateList = new ArrayList<>();
		List<ValidationError> allErrors = new ArrayList<>();
		int i = 0;
		List<ID> result = new ArrayList<>();
		Set<ID> processedIds = new HashSet<>();
		for (T obj : objList) {
			i++;
			ID id = getId(obj);
			try {
				boolean exists = false;
				if (id != null) {
					if (processedIds.contains(id)) {
						/*
						 * Duplicate Ids are not allowed in the same request
						 */
						throw new ValidationException("id", UniqueKey.class.getSimpleName(),
								"must be unique in request");
					}
					exists = repo.existsById(id);
					processedIds.add(id);
				}

				if (!exists) {
					addList.add(obj);
				} else {
					updateList.add(obj);
				}
			} catch (ValidationException e) {
				setFieldIndex(e.getErrors(), i);
				allErrors.addAll(e.getErrors());
			}
		}
		if (!allErrors.isEmpty()) {
			throw new ValidationException(allErrors);
		}
		addAll(addList);
		updateAll(updateList);
		return result;
	}

	private void setFieldIndex(List<ValidationError> errors, int index) {
		for (ValidationError err : errors) {
			// put index right after the field name. If the field is a child object, then
			// the index of child collection is already there. Parent index should come
			// first.
			String[] fieldParts = StringUtils.split(err.getField(), '.');
			fieldParts[0] = fieldParts[0] + "." + index;

			err.setField(StringUtils.join(fieldParts, '.'));
		}
	}

	@Transactional(readOnly = false)
	public void update(ID id, T obj) {
		validate(obj, Operations.Update.class);
		updateInternal(Arrays.asList(obj));
	}

	@Transactional(readOnly = false)
	public void updateAll(List<T> objList) {
		validate(objList, Operations.Update.class);
		updateInternal(objList);
	}

	@Transactional(readOnly = false)
	public void delete(ID id) {
		deleteInternal(id);
	}

	@Transactional(readOnly = false)
	public void deleteAllForIds(List<ID> ids) {
		for (ID id : ids) {
			deleteInternal(id);
		}
	}

	@Transactional(readOnly = false)
	public void deleteAllForIds(Set<ID> ids) {
		for (ID id : ids) {
			deleteInternal(id);
		}
	}

	@Transactional(readOnly = false)
	public void deleteAllForObjs(List<T> objList) {
		for (T obj : objList) {
			deleteInternal(getId(obj));
		}
	}

	private void deleteInternal(ID id) {
		T saved = getById(id);
		// check of reference
		ensureNoReferences(saved);
		beforeDelete(saved);
		repo.delete(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Delete, (Auditable) saved, "Deleted", null);
		}
		afterDelete(saved);
		fireResourceChangeEvent(saved, Crud.Delete);
	}

	protected void verifyUniqueId(T obj, ID id) {
		T saved = findById(id);
		if (saved != null) {
			throw new BadRequestException("Functional id '" + getId(obj) + "' is already used");
		}
	}

	protected List<AuditLog> additionalHistory(ID id) {
		return null;
	}

	protected void save(T obj) {
		repo.save(obj);
	}

	protected void beforeSave(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		// entity specific login can come here
	}

	protected void afterSave(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		// entity specific login can come here
	}

	protected void beforeDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void afterDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void saveHistory(String action, Auditable obj, String details, String filter) {
		ID id = getId(obj);
		if (obj instanceof AuditableParent) {
			auditService.add(action, (AuditableParent) obj, id, details, filter);
		} else if (obj instanceof AuditableChild) {
			saveChildHistory(action, (AuditableChild<?>) obj, details);
		} else if (obj instanceof AuditableReference) {
			saveReferenceHistory(action, (AuditableReference<?, ?>) obj, details);
		}
	}

	protected void saveChildHistory(String action, AuditableChild<?> obj, String details) {
		Object parentId = obj.getParentId();
		Object parent = EntityManagerProvider.getEntityManager().find(obj.getParentEntity(), parentId);
		if (parent == null) {
			throw new IllegalArgumentException(
					"Parent entity '" + obj.getParentEntity().getName() + " does not exist for id: " + parentId);
		}
		details += " [" + obj.getName() + "]";
		auditService.add(Actions.Crud.Update, (AuditableParent) parent, parentId, details, obj.getClass().getSimpleName());
	}

	protected void saveReferenceHistory(String action, AuditableReference<?, ?> obj, String details) {
		Object parentId = obj.getParentId();
		// find parent entity
		Object parent = EntityManagerProvider.getEntityManager().find(obj.getParentEntity(), parentId);
		if (parent == null) {
			throw new IllegalArgumentException(
					"Parent entity '" + obj.getParentEntity().getName() + " does not exist for id: " + parentId);
		}
		// find referenced entity
		AuditableParent ref = EntityManagerProvider.getEntityManager().find(obj.getReferenceEntity(),
				obj.getReferenceId());
		if (ref == null) {
			throw new IllegalArgumentException("Reference entity '" + obj.getReferenceEntity().getName()
					+ " does not exist for id: " + obj.getReferenceId());
		}

		details += " [" + ref.getName() + "]";
		auditService.add(Actions.Crud.Update, (AuditableParent) parent, parentId, details, obj.getClass().getSimpleName());
	}

	public boolean isEqual(Object compareWith, Object obj) {
		String changes = compareAndCopy(compareWith, obj, false, false);
		return StringUtils.isEmpty(changes);
	}

	public String compareAndCopy(Object compareWith, Object obj) {
		return compareAndCopy(compareWith, obj, true, true);
	}

	public String compareAndCopy(Object compareWith, Object obj, boolean onlyNonNullValues,
			boolean copyValue2CompareWith) {
		DiffBuilder<Object> builder = new DiffBuilder<>(compareWith, obj, ToStringStyle.NO_CLASS_NAME_STYLE);

		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			if (field.getName().equals("serialVersionUID")) {
				continue;
			}
			field.setAccessible(true);
			Object value;
			try {
				value = PropertyUtils.getProperty(obj, field.getName());
				Boolean updateable = onlyNonNullValues ? value != null : true;
				boolean isTransient = isFieldTransient(field);
				if (updateable) {
					updateable = !isFieldReadOnly(field);
				}
				if (updateable && !isTransient) { // transient fields are not change detected
					Object oldValue = PropertyUtils.getProperty(compareWith, field.getName());
					if (value instanceof Date) {
						Date dateValue = (Date) value;
						dateValue = adjustTemporalValue(field, dateValue, obj);
						// date is not properly formatted in diff, convert to string
						String newValueStr = null;
						String oldValueStr = null;
						;
						if (value != null) {
							newValueStr = DateUtils.formatTimestamp(dateValue) + " " + TimeZone.getDefault().getID();
						}
						if (oldValue != null) {
							oldValueStr = DateUtils.formatTimestamp((Date) oldValue) + " "
									+ TimeZone.getDefault().getID();
						}
						builder.append(field.getName(), oldValueStr, newValueStr);
					} else {
						builder.append(field.getName(), oldValue, value);
					}
				}
				if (updateable && copyValue2CompareWith) {
					PropertyUtils.setProperty(compareWith, field.getName(), value);
				}
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}
		String result = builder.build().toString();
		// replace the message
		result = StringUtils.replace(result, "differs from", "changed to");
		return result;
	}

	private void adjustTemporalFields(Object obj) {
		// truncatet the time part for the date only fields
		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			if (!field.getType().equals(Date.class)) {
				continue;
			}
			field.setAccessible(true);
			Object value;
			try {
				value = PropertyUtils.getProperty(obj, field.getName());
				Date dateValue = (Date) value;
				adjustTemporalValue(field, dateValue, obj);
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}

	}

	private Date adjustTemporalValue(Field field, Date value, Object obj) {
		if (value == null) {
			return null;
		}
		Temporal anno = field.getAnnotation(Temporal.class);
		if (anno == null) {
			return value;
		}
		if (anno.value() == TemporalType.DATE) {
			// remove the time part from the date
			Date newValue = DateUtils.toStartOfDay(value);
			try {
				PropertyUtils.setProperty(obj, field.getName(), newValue);
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
			return newValue;
		}
		return value;
	}

	@SuppressWarnings("unchecked")
	private void addInternal(List<T> objList) {
		for (T obj : objList) {
			setAuditData(obj, Operations.Add.class);
			verifyStatusField(obj);
			adjustTemporalFields(obj);
			ensureUniqueKeys(obj, null, Operations.Add.class);
			beforeSave(obj, null, Operations.Add.class);
			if (generateKey) {
				// generate key when it is not optional, or it is optional but not set.
				ID id = getId(obj);
				if (!generateKeyOptional
						|| (generateKeyOptional && (id == null || StringUtils.isEmpty(id.toString())))) {
					setId(obj, (ID) CommonUtil.genUUID());
				}
			}
		}
		repo.saveAll(objList);
		for (T obj : objList) {
			if (obj instanceof Auditable && !auditFields.containsKey(AuditFieldType.CREATE_DATE)) {
				// Save history for Add only when it is not saved in the entity table.
				saveHistory(Actions.Crud.Add, (Auditable) obj, "Added", null);
			}
			afterSave(obj, null, Operations.Add.class);
			fireResourceChangeEvent(obj, Crud.Add);
		}
	}

	private void overwriteInternal(ID id, T obj) {
		ID objId = getId(obj);
		if (objId != null && !objId.equals(id)) {
			throw new BadRequestException("ID field cannot be updated");
		}
		setId(obj, id);
		T saved = getById(id);
		verifyStatusField(obj);
		adjustTemporalFields(obj);
		ensureUniqueKeys(obj, saved, Operations.Overwrite.class);
		beforeSave(obj, saved, Operations.Overwrite.class);
		T copy = copy(saved);
		String changes = compareAndCopy(saved, obj, false, true);
		if (StringUtils.isEmpty(changes)) {
			LOG.info(String.format("Nothing to update in '%s' for ID '%s'", saved.getClass().getSimpleName(),
					getId(saved).toString()));
			afterSave(obj, copy, Operations.Overwrite.class);
			return;
		}
		setAuditData(obj, Operations.Overwrite.class);
		save(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Overwrite, (Auditable) obj, changes, null);
		}

		afterSave(obj, copy, Operations.Overwrite.class);
		fireResourceChangeEvent(obj, Crud.Overwrite);
	}

	private void updateInternal(List<T> objList) {
		List<T> saveList = new ArrayList<>();
		List<T> copyList = new ArrayList<>();
		List<String> changeList = new ArrayList<>();
		for (T obj: objList) {
			ID id = getId(obj);
	
			setId(obj, id);
			T saved = getById(id);
			ensureUniqueKeys(obj, saved, Operations.Update.class);
			beforeSave(obj, saved, Operations.Update.class);
			T copy = copy(saved);
			String changes = compareAndCopy(saved, obj);
			if (StringUtils.isEmpty(changes)) {
				LOG.debug(String.format("Nothing to update in '%s' for ID '%s'", saved.getClass().getSimpleName(),
						getId(saved).toString()));
				continue;
			}
			setAuditData(saved, Operations.Update.class);
			saveList.add(obj);
			copyList.add(copy);
			changeList.add(changes);
		}
		repo.saveAll(saveList);
		for (int i=0; i < saveList.size(); i++) {
			T saved = saveList.get(i);
			if (saved instanceof Auditable) {
				saveHistory(Actions.Crud.Update, (Auditable) saved, changeList.get(i), null);
			}
	
			afterSave(saved, copyList.get(i), Operations.Update.class);
			fireResourceChangeEvent(saved, Crud.Update);
		}
	}

	private T copy(T obj) {
		try {
//			@SuppressWarnings("deprecation")
			T newObj = entityClass.newInstance();
			PropertyUtils.copyProperties(newObj, obj);
			return newObj;
		} catch (InstantiationException | IllegalAccessException e) {
			throw new IllegalStateException(e);
		} catch (InvocationTargetException e) {
			throw new IllegalStateException(e);
		} catch (NoSuchMethodException e) {
			throw new IllegalStateException(e);
		}

	}

	private void validate(T obj, Class<? extends Operations.Operation> operation) {
		Set<? extends ConstraintViolation<?>> errors = validator.validate(obj, operation, Default.class);
		if (!errors.isEmpty()) {
			throw new ValidationException(errors);
		}
	}

	private void validate(List<T> objList, Class<? extends Operations.Operation> operation) {
		List<ValidationError> allErrors = new ArrayList<>();
		int i = 0;
		for (T obj : objList) {
			i++;
			Set<ConstraintViolation<Object>> errors = validator.validate(obj, operation, Default.class);
			List<ValidationError> errorsForObj = ValidationError.from(errors);
			setFieldIndex(errorsForObj, i);
		}

		if (!allErrors.isEmpty()) {
			throw new ValidationException(allErrors);
		}
	}

	private void ensureUniqueKeys(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		/*
		 * TODO: Null checking of all values. It is possible to have null values for
		 * unique key fields
		 */
		if (uniqueKeyFields == null || uniqueKeyFields.isEmpty())
			return;
		for (String key : uniqueKeyFields.keySet()) {
			List<Field> fields = uniqueKeyFields.get(key);
			List<Object> values = BeanUtil.getFieldValue(newObj, fields);
			List<Object> compareValues = new ArrayList<>();
			boolean validate = false;
			if (operation.equals(Operations.Add.class)) {
				// for add simply check if there are records for the same values
				// no need for checking when all unique key fields are null
				for (Object value : values) {
					if (value != null) {
						validate = true;
					}
				}
				compareValues = values;
			} else {
				/*
				 * for update it is complicated. Since there could be multiple fields in a
				 * unique key, below points are considered 1. First check if any of the field in
				 * the key has changed. 2. If any field has changed: if the new value is null
				 * use the old value, otherwise the new value
				 */
				int i = 0;
				List<Object> oldValues = BeanUtil.getFieldValue(oldObj, fields);
				for (Object oldValue : oldValues) {
					Object value = values.get(i);
					compareValues.add(value == null ? oldValue : value);
					if (oldValue == null && value != null) {
						validate = true;
					} else if (value != null && !oldValue.equals(value)) {
						validate = true;
					}
					i++;
				}
			}
			if (validate) {
				long count = EntityUtils.findRecordCount(entityClass, fields, compareValues);
				if (count > 0) {
					throw new ValidationException(key, UniqueKey.class.getSimpleName(), "must be unique");
				}
			}
		}
	}

	private void ensureNoReferences(T obj) {
		List<EntityReferenceCacheEntry> refs = staticCache.getEntityReferenceCache().getEntityReferences()
				.get(obj.getClass());
		if (refs == null) {
			return;
		}
		ID id = getId(obj);
		List<ValidationError> errors = new ArrayList<>();
		for (EntityReferenceCacheEntry ref : refs) {

			long refCount = EntityUtils.findRecordCount(ref.getReferencedInEntity(), ref.getReferencedInField(), id);
			if (refCount != 0) {
				String msg = String.format("%d reference(s) found in '%s'", refCount,
						ref.getReferencedInEntity().getSimpleName());
				ValidationError error = new ValidationError(null, msg, null);
				errors.add(error);
			}
		}
		if (errors.size() != 0) {
			ErrorResponse resp = RestResponseBuilder.errorResponse(null, null, errors);
			throw new InvalidRequestException(resp);
		}
	}

	private void verifyStatusField(T obj) {
		if (statusField == null) {
			return;
		}

		try {
			Object statusValue = FieldUtils.readField(statusField, obj, true);
			Object newValue = null;
			if (statusField.getType().equals(String.class)) {
				// set status if currently null or empty
				if (statusValue == null || StringUtils.isEmpty(statusValue.toString())) {
					newValue = statusFieldDefault;
				}
			} else if (statusField.getType().equals(Boolean.class)) {
				// boolean status true/false
				if (statusValue == null) {
					newValue = Boolean.valueOf(statusFieldDefault);
				}
			}
			if (newValue != null) {
				FieldUtils.writeField(statusField, obj, newValue, true);
			}
		} catch (IllegalAccessException e) {
			// should not happen. still do not eat the exception
			throw new IllegalStateException(e);
		}

	}

	private boolean isFieldReadOnly(Field field) {
		Schema annotation = field.getAnnotation(Schema.class);
		if (annotation != null) {
			@SuppressWarnings("deprecation")
			Boolean readOnly = annotation.readOnly();
			if (readOnly) {
				return true;
			}
			AccessMode accessMode = annotation.accessMode();
			if (AccessMode.READ_ONLY.equals(accessMode)) {
				return true;
			}
		}
		AuditField auditField = field.getAnnotation(AuditField.class);
		if (auditField != null) {
			// audit fields are ready only from the outside
			return true;
		}
		return false;
	}

	private boolean isFieldTransient(Field field) {
		Transient transAnno = field.getAnnotation(Transient.class);
		if (transAnno != null) {
			return true;
		}
		return false;
	}

	protected void fireResourceChangeEvent(T obj, String action) {
		if (!(obj instanceof AppObect)) {
			return;
		}
		AppObect res = (AppObect) obj;
		ResourceChangeEvent<AppObect> event = new ResourceChangeEvent<AppObect>(this, res,
				res.getClass().getSimpleName(), action);
		publisher.publishEvent(event);
	}

	public void setAuditData(Object obj, Class<? extends Operations.Operation> operation) {
		if (operation.equals(Operations.Add.class)) {
			setAuditField(obj, AuditFieldType.CREATE_DATE, new Date());
			setAuditField(obj, AuditFieldType.CREATE_USER, getLoggedUser());
		} else if (operation.equals(Operations.Update.class) || operation.equals(Operations.Overwrite.class)) {
			setAuditField(obj, AuditFieldType.UPDATE_DATE, new Date());
			setAuditField(obj, AuditFieldType.UPDATE_USER, getLoggedUser());
		}
	}

	private void setAuditField(Object obj, AuditFieldType auditType, Object value) {
		Field field = auditFields.get(auditType);
		if (field != null) {
			writeField(field, obj, value);
		}
	}

	protected boolean isAdd(Class<? extends Operations.Operation> operation) {
		return Operations.Add.class.equals(operation);
	}

	protected boolean isUpdate(Class<? extends Operations.Operation> operation) {
		return Operations.Update.class.equals(operation);
	}

	protected boolean isOverwrite(Class<? extends Operations.Operation> operation) {
		return Operations.Overwrite.class.equals(operation);
	}

	protected boolean isBulk(Class<? extends Operations.Operation> operation) {
		return Operations.Bulk.class.equals(operation);
	}

	protected String getAppObjectType() {
		return entityClass.getSimpleName();
	}
}
